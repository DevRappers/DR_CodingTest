//
//  sort4.c
//  CodingTest
//
//  Created by 이재준 on 22/10/2019.
//  Copyright © 2019 DevRappers. All rights reserved.
//
/*
    퀵 정렬(Quick Sort)
    저번까지 다루었던 선택 정렬, 버블 정렬, 삽입 정렬 알고리즘은 모두 시간 복잡도 O(N^2)를 가지는 알고리즘임.
    데이터가 많아지면 일반적인 상황에서 사용하기 매우 알고리즘이기 때문에 더욱 빠른 알고리즘이 사용될 필요가 있음.
    그 대표적인 알고리즘이 바로 퀵 정렬 알고리즘임. 퀵 정렬은 대표적인 '분할 정복' 알고리즘으로 평균 속도가 O(N*logN)임
    
    퀵 정렬은 하나의 큰 문제를 두 개의 작은 문제로 분할하는 식으로 빠르게 정렬함
    쉽게 말하자면 특정한 값을 기준으로 큰 숫자와 작은 숫자를 서로 교환한 뒤에 배열을 반으로 나눔
    [특정한 값을 기준으로 큰 숫자와 작은 숫자를 나누면 어떨까?]
    일반적으로 퀵정렬에서는 기준 값이 있음. 이를 피벗(Pivot)이라고 함 보통 첫 번째 원소를 피벗 값으로 설정하고 사용함. 다음과 같이 3이라는
    값이 먼저 피벗 값으로 설정이 되었다고 생각함
    왼쪽에서는 p값보다 큰값 오른쪽에서 p값보다 작은값을 찾음 그 값들을 서로 바꿔줌.
    작은 값의 인덱스와 큰값의 인덱스가 엇갈릴 경우 작은 값의 인덱스가 큰값의 인덱스보다 작아질경우 p값가 가장 작은값을 바꿔줌. 원래 피봇을 기준을 해줌
    왼쪽 배열 오른 쪽 배열을 분할해주고 만약에 왼쪽배열부터 p값으로 똑같이 진행함. 자기보다 큰값을 못찾으면 그냥 피봇이 기준이됨
    p A              B
    3 7 8 1 5 9 6 10 2 4
    --------------------
    p   A B
    3 2 8 1 5 9 6 10 7 4
    --------------------
    p   B A
    3 2 1 8 5 9 6 10 7 4
    --------------------
    p(완료)p
    1 2 3 8 5 9 6 10 7 4
    --------------------
          p   A        B
    1 2 3 8 5 9 6 10 7 4
    --------------------
          p       A  B
    1 2 3 8 5 4 6 10 7 9
    --------------------
          p       B  A
    1 2 3 8 5 4 6 7 10 9
    --------------------
          p         p
    1 2 3 7 5 4 6 8 10 9
    --------------------
          p     B
    1 2 3 7 5 4 6 8 9 10
    ..  이런식으로 진행됨
    
    1 2 3 4 5 6 7 8 9 10
    N^2 = 10 * 10 = 100
 
    퀵정렬 분할을 사용한다면
    1 2 3 4 5 => 5 * 5 = 25
    6 7 8 9 10 => 5 * 5 = 25
    
    평균 시간 복잡도는
    O(n*logN)
    퀵 정렬의 최악 시간 복잡도는 O(N^2)까지 간다. 1 2 3 4 5 6 7 8 9 10 같이 이미 정렬이 되어 있는 경우에는 느리다.
*/

#include <stdio.h>

int number = 10;
int data[10] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9};

void quickSort(int *data, int start, int end){
    if(start >= end){   // 원소가 1개인 경우
        return;
    }
    
    int key = start;    // 키는 첫번째 원소
    int i = start + 1;  // 왼쪽 출발지점
    int j = end;        // 오른쪽 출발지점
    int temp;
    
    // 엇갈릴 때 까지 반복
    while(i <= j){
        // 내림차순으로 바꿀때는>= <=로 바꿔주면됨
        while(data[i]<= data[key])  // 키 값보다 큰 값을 만날때 까지 오른쪽으로 이동
        {
            i++;
        }
        while(data[j] >= data[key] && j>start) // 키 값보다 작은 값을 만날때 까지 왼쪽으로 이동 / j가 start보다는 커야하니까 범위를 벗어나면 안되서
        {
            j--;
        }
        if(i> j){   // 현재 엇갈린 상태면 키값과 교체함
            temp = data[j];
            data[j] = data[key];
            data[key] = temp;
        }
        else{       // 엇갈리지 않았다면 양쪽의 값을 변경해줘야함
            temp = data[j];
            data[j] = data[i];
            data[i] = temp;
        }
    }
    
    // 바깥으로 빠져 나오는 경우에는 그 키값을 기준으로 왼쪽과 오른쪽에서 다시 퀵정렬을 실행시켜줌
    quickSort(data, start, j-1);
    quickSort(data, j+1, end);
}

int main(void){
    quickSort(data, 0, number-1);
     // 출력
    for(int i=0;i<number;i++){
        printf("%d ",data[i]);
    }
    printf("\n");
    return 0;
}
